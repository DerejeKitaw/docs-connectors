= MQTT 3 Connector 1.0 - Mule 4

Support Category: https://www.mulesoft.com/legal/versioning-back-support-policy#anypoint-connectors[Select]

Anypoint Connector for MQTT 3 (MQTT 3 Connector) is an MQTT (Message Queuing Telemetry Transport) version 3.x protocol compliant MuleSoft extension. MQTT is a lightweight publish/subscribe messaging protocol designed for connecting remote devices with a small code footprint and minimal network bandwidth. MQTT today is used in a wide variety of industries, such as automotive, manufacturing, telecommunications, oil and gas.

The connector consumes and produces MQTT messages and supports all MQTT v3.x functionalities including message retention, last will and testament messages, and persistent sessions.

For compatibility information and fixed issues, see the MQTT 3 Connector Release Notes.

== Prerequisites

To use this connector, you must be familiar with:

* MQTT v3.x protocol
* Anypoint Connectors
* Mule runtime engine (Mule)
* Elements and global elements in a Mule flow
* Creating a Mule app using Anypoint Studio (Studio)

Before creating an app, you must have Anypoint Platform and Anypoint Studio.

== Common Use Cases for Connector

These are some common use cases for MQTT 3 Connector:

* Connect to MQTT brokers by specifying a failover server list that the client iterates over until a connection is successfully established.
* Connect to MQTT brokers in reliable messaging schema and publish messages.
* Connect to an MQTT broker and set a last will and testament (LWT) message to notify all the subscribers of the clientâ€™s disconnection.
* Connect to an MQTT broker with TLS and listen for messages.
* Listen for messages on a unique or multiple topics.
* Listen for messages on multiple topics using single-level or multi-level wildcards.
* Publish messages to a topic.
* Publish messages with retention.
* Publish messages to an MQTT topic and set different Quality of Service (QoS) levels of delivery assurance for inbound or outbound messages.

== Configure the Connector

MQTT 3 Connector comes with default values for both publishing and consuming messages. To use the connector, the only requirement is that you must configure which connection to use and that you specify a value for the client ID, which will uniquely identify that connection.

=== Configure the Connection

To configure the connection, you specify a connection URL to the broker.

In the following XML example, you configure a minimal connection to a broker. The `<mqtt3:connection>`, `clientId` and `url` configurations look like this:

[source,xml,linenums]
----
<mqtt3:config name="MQTT_Config">
    <mqtt3:connection clientId="smart-bentley-123" url="tcp://127.0.0.1:1883" />
</mqtt3:config>
----

You can also specify each URL field separately for the connection by configuring the form connection, which enables you to specify a protocol, host and port to establish a connection with the broker.

In the following example, you configure the form connection to a broker. The `<mqtt3:form-connection>`, `protocol`, `host`, `port` and `clientId` configurations look like these:

[source,xml,linenums]
----
<mqtt3:config name="MQTT_Form_Config">
    <mqtt3:form-connection clientId="smart-bentley-123" username="usertest" password="testpass" protocol="TCP" host="127.0.0.1" port="1883"/>
</mqtt3:config>
----

=== Configure the Client ID

The client ID is mandatory because it identifies an MQTT connection to a broker. Define a meaningful name that uniquely identifies a client or device that connects to an MQTT broker and not a random string.

In the following example, you configure the client ID `smart-bentley-123`. The `clientID` configuration looks like this:

[source,xml,linenums]
----
<mqtt3:config name="MQTT_Config">
    <mqtt3:connection clientId="smart-bentley-123" url="tcp://127.0.0.1:1883" />
</mqtt3:config>
----

=== Configure Advance Connection Options

MQTT 3 Connector enables you to define multiple default parameters while consuming or publishing messages. This way, you can define a global default behavior for all the operations associated with the configurations.

In the following example, you configure the keep alive internal and keep alive internal unit to set the maximum period of time that the connection is kept alive without any messages being exchanged between the client and broker. You also configure the maximum number of in-flight messages allowed:

The `keepAliveInterval`, `keepAliveIntervalUnit`, and `maxInFlight` configurations look like these:

[source,xml,linenums]
----
<mqtt3:config name="MQTT_Config">
  <mqtt3:connection clientId="smart-bentley-123" url="tcp://127.0.0.1:1883">
      <mqtt3:connection-options maxInFlight="60" keepAliveInterval="60" keepAliveIntervalUnit="SECONDS" />
  </mqtt3:connection>
</mqtt3:config>
----

You can also configure the following connection options:

* `maxInFlight` +
The maximum amount of messages that can be unacknowledged at a given time.
* `cleanSession` +
If set to `true`, the session is cleaned each time the client disconnects from the broker.
* `enableFilePersistence` +
If set to `true`, creates a file-based persistent data store, used to store outbound and inbound messages while they are in flight, enabling delivery to the QoS specified.
* `keepAliveInterval` +
The amount of time that the connection between the client and broker is kept alive without any messages exchanged.
* `keepAliveIntervalUnit` +
The unit of time that corresponds to the `keepAliveInterval` parameter
* `connectionTimeout` +
The socket connection timeout value. This attribute works in tandem with `timeoutUnit`. In the case of multiple fail-over URLs provided, the timeout applies to each URL individually.
* `timeoutUnit` +
A time unit to qualify the `connectionTimeout` attribute.


== Specify a Connection Protocol

MQTT supports protocols, which can be used to connect to and exchange MQTT messages with the broker. Configure the protocol in the connection string of the connector configuration. The default is TCP:

* TCP
* SSL/TLS
* WS
* WSS
* LOCAL


== Configure Credentials For Authentication

Authentication credentials are optional, but you can provide a username and a password if it is required.

In the following example, you configure the authentication in the `<mqtt3:connection>` by providing a basic `username` and `password`:

[source,xml,linenums]
----
<mqtt3:config name="MQTT_Config">
    <mqtt3:connection clientId="smart-bentley-123" username="usertest" password="passtest" url="tcp://127.0.0.1:1883"/>
</mqtt3:config>
----

You can also provide a client certificate to authenticate the connection by setting a TLS context. In the following example, the `<tls:context>` configuration looks like this:

[source,xml,linenums]
----
<mqtt3:config name="MQTT_TLS_Config">
    <mqtt3:connection clientId="smart-bentley-tls-123" username="usertest" password="passtest" url="ssl://localhost:8883" >
        <tls:context>
            <tls:trust-store path="tls/truststore.jks" password="racing" type="jks"/>
        </tls:context>
        <mqtt3:connection-options maxInFlight="60" cleanSession="true" />
    </mqtt3:connection>
</mqtt3:config>
----


== Provide a Failover Server List

There are certain deployment schemas that consist of multiple brokers working together in order to provide clients with several connection endpoints. When there is more than one available server that the client can connect to, there are two possible scenarios: either each MQTT server is operating separately or they might be working together and sharing a state (cluster mode), in which case, you might want to specify how the MQTT client will behave in the event of a reconnection.

When you provide a failover server list, the connector can iterate over it until it successfully establishes a connection with one of the provided endpoints.

In the following example, the `<mqtt3:fail-over-connection>` and `<mqtt3:fail-over-url` configurations look like this:

[source,xml,linenums]
----
<mqtt3:config name="MQTT_FailOver_Config">
    <mqtt3:fail-over-connection clientId="smart-bentley-123" >
        <mqtt3:fail-over-servers >
            <mqtt3:fail-over-url protocol="TCP" host="127.9.0.2" port="1883"/>
            <mqtt3:fail-over-url protocol="TCP" host="127.0.0.3" port="1884"/>
            <mqtt3:fail-over-url protocol="TCP" host="127.0.0.1" port="1883"/>
        </mqtt3:fail-over-servers>
        <mqtt3:connection-options maxInFlight="60" cleanSession="true" connectionTimeout="60" />
        </mqtt3:fail-over-connection>
</mqtt3:config>
----

== Configure the Clean Session

Set the clean session (`cleanSession`) flag to `false` so the broker remembers the client the next time it connects. While the client is offline, all its subscriptions are saved, and Quality of Service (QoS) 1 and 2 messages that the client would want to receive are saved too, until the client reconnects.

Some brokers support the clustering of MQTT brokers in which the nodes share a state. In this case, setting the clean session flag to `false` can be useful if the node the connector is talking to happens to go offline. This enables the client to reconnect to a different node that is aware of the client's subscriptions so that any messages the connector might have missed while offline are delivered.

If clean session is set to `true` (default), then when the connector disconnects, for whatever reason, all its subscriptions will be dropped and it will have to resubscribe upon reconnection. All messages sent for it while offline are lost.

In the following example, the `cleanSession` configuration looks like this:

[source,xml,linenums]
----
<mqtt3:config name="MQTT_Config">
  <mqtt3:connection clientId="smart-bentley-123" url="tcp://127.0.0.1:1883">
      <mqtt3:connection-options cleanSession="false"/>
    </mqtt3:connection>
</mqtt3:config>
----

== Enable File Persistence

Enabling file persistence by setting the `enableFilePersistence` flag to `true`, enables the MQTT client to persist its state
to a file that is used to store any outbound or inbound in-flight messages the client might have with QoS â‰¥ 1. In contrast,
if `enableFilePersistence` flag is set to `false`, the client state is only saved in memory and in the event of a crash
the client is not be able to recover its state.

In the following example, the `enableFilePersistence` configuration looks like this:

[source,xml,linenums]
----
<mqtt3:config name="MQTT_Config">
  <mqtt3:connection clientId="smart-bentley-123">
       <mqtt3:connection-options cleanSession="false" />
       <mqtt3:file-persistence-options enableFilePersistence="true" />
    </mqtt3:connection>
</mqtt3:config>
----

You can specify where you want the persistent store to be generated by setting the datastore parameter.

[source,xml,linenums]
----
<mqtt3:config name="MQTT_Config">
  <mqtt3:connection clientId="smart-bentley-123">
       <mqtt3:connection-options cleanSession="false" />
       <mqtt3:file-persistence-options enableFilePersistence="true" dataStorePath="mqtt/store"/>
    </mqtt3:connection>
</mqtt3:config>
----

WARNING: if you set a dynamic client id, in the event of a crash, the connector will not be able to recover the persisted
files. To use this feature effectively, you must set a client id that will not change in the event of an application restart
after a crash.

== See Also

* xref:connectors::introduction/introduction-to-anypoint-connectors.adoc[Introduction to Anypoint Connectors]
* xref:connectors::introduction/intro-use-exchange.adoc[Use Exchange to Discover Connectors, Templates, and Examples]
* https://help.mulesoft.com[MuleSoft Help Center]
