= Configure HTTP Request Operation
:page-aliases: connectors::http/http-request-ref.adoc

Anypoint Connector for HTTP (HTTP Connector) *Request* operation enables you to consume an external HTTP service using the default `GET` method. You can choose what methods the operation accepts.

* The `GET` and `OPTIONS` methods do not send the payload in the request, the body of the HTTP request is empty.
* The `CONNECT`, `DELETE`, `PATCH`, `POST`, and `PUT` methods send the message payload as the body of the HTTP request.

After the HTTP *Request* operation sends an HTTP request, the connector receives an HTTP response and passes it to the next element in the Mule app's flow. The HTTP response can be successful or not and return different status codes. You can also customize how the operation generates HTTP responses in the connector operation configuration.

By default, the operation sends the Mule message payload as the HTTP request body but you can customize it using a DataWeave script or expression. In addition to the body of the request, you can configure:

* Request and response size limits
* Headers
* Query parameters
* URI parameters
* A map of multiple headers or parameters

== Configure HTTP Request Connection

To use an HTTP *Request* operation, the required minimum setting for the operation is a *Host* URI, which can include a path. You can configure a connection with these settings:

* *Host* +
Indicates where the requests are sent.
* *Port* +
Indicates where the requests are received.
* *Protocol* +
Indicates the protocol for communication, either HTTP for plain connections or HTTPS for TLS secure connections.

To enable secure connections through HTTPS, you must define a *TLS Configuration* context in the connection and provide:

* A keystore for the server
* A truststore if you need two-way authentication

Refer to the xref:mule-runtime::tls-configuration.adoc[Configure TLS with Keystores and Truststores] documentation for details.

Additionally, you can configure the following *Authentication* types for the operation:

* *Basic authentication*
* *Digest authentication*
* *Ntlm authentication* (NT LAN Manager)

The following example shows how to configure the HTTP *Request* connection in Studio:

. In the *Mule Palette* view, select *HTTP > Request*.
. Drag *Request* to the Studio canvas.
. Click the plus sign (*+*) next to the *Connector configuration* field to configure a global element that can be used by all instances of HTTP *Request* in the app.
. Set *Host* to `localhost` and *Port* to `8081`.

image::http-listener-1.png[HTTP Request global configuration window with Host field set to localhost and Port field to 8081]
[start=5]
. Set *TLS configuration* to *Edit inline*.
. In the *Trust Store Configuration* section, set *Path* to `keystore.jks` and *Password* to `Mypassword`.

image::http-listener-2.png[Trust Store Configuration window with Path field set to keystore.jks and Password field to Mypassword]

[start=7]
. Set *Authentication* to *Basic authentication*.
. Set *Username* to `testuser` and *Password* to `Myuser`.
. Click *OK*.
. In the HTTP *Request* configuration screen, set *Path* to `/testpath`.

image::http-listener-3.png[Authentication field set to Basic authentication and User field set to testuser and Password field to Myuser]

In the *Configuration XML* editor, the `host`, `port`, `path`, `trust-store`, and `authentication` configurations look like these:

[source,xml,linenums]
----
<http:request-config name="HTTP_Request_configuration">
		<http:request-connection host="localhost" port="8081">
			<tls:context >
				<tls:trust-store path="keystore.jks" password="Mypassword" />
			</tls:context>
			<http:authentication >
				<http:basic-authentication username="testuser" password="Myuser" />
			</http:authentication>
		</http:request-connection>
	</http:request-config>
  <flow name="httplistenerresponseFlow1" >
  <http:request method="GET" config-ref="HTTP_Request_configuration" path="/testpath"/>
</flow>
----

== Map Between Mule Messages and HTTP Requests

By default, the HTTP request operation sends the Mule message payload as the HTTP request body but you can customize it using a DataWeave script or expression.


== Configure HTTP Request and Response Size Limits

By default, Mule defines different limits for the HTTP request size, response size, and request/response header size. However, you can change these max values by modifying the following properties in the `wrapper.conf` file:

[%header%autowidth.spread,cols="a,a,a"]
|===
| Maximum Allowed Value | Property | Default Value (in bytes)
| Request/Response Header Size |  `mule.http.headerSectionSize` | `8192`
| Request Size | `org.glassfish.grizzly.nio.transport.TCPNIOTransport.max-receive-buffer-size` | `1048576` (1MB)
| Response Size | `org.glassfish.grizzly.nio.transport.TCPNIOTransport.max-send-buffer-size` | `1048576` (1MB)
|===

To learn how to set system properties in the `wrapper.conf` file, refer to the xref:mule-runtime::mule-app-properties-system.adoc#set-properties[Set System Properties in the wrapper.conf File] documentation.

== Configure Headers

To add headers to an HTTP request, you can configure two options:

* *Headers* +
At the HTTP *Request* operation level.
* *Default headers* +
At the HTTP global connection level.

You configure default headers at the HTTP global connection level so that you don't have to specify every header on every single request. With this configuration, those headers are added to every outbound request, alongside any headers you configure at the HTTP *Request* operation level.
Additionally, the default headers also accept expressions, allowing you to use dynamic values.

The following example shows how to configure *Headers* at HTTP *Request* operation level in Studio:

. Select the HTTP *Request* operation from your flow.
. In *General*, select the *Headers* tab.
. Click the plus sign (*+*) to add a new header.
. In the *Name* column, change *"Key"* to `"HeaderName1"`.
. In the *Value* column, change *"Value"* to `"HeaderValue1"`.

image::http-listener-3.png[Headers configuration at HTTP Request operation level]

In the *Configuration XML* editor, the `headers` configuration looks like this:

[source,xml,linenums]
----
<http:request method="GET" config-ref="HTTP_Request_configuration" path="/testpath">
			<http:headers ><![CDATA[#[output application/java
---
{
	"HeaderName1" : "HeaderValue1"
}]]]></http:headers>
		</http:request>
----

You can use DataWeave expressions to add headers as well, for example:

. In the HTTP *Request* operation configuration window, select the *Headers* tab.
. Select the *fx* button to switch to literal mode.
. In the box, add the DataWeave expression `[{'HeaderName1' : 'HeaderValue1'}]`.

image::http-listener-3.png[Headers configuration at HTTP Request operation level with DataWeave expression]

In the *Configuration XML* editor, the `headers` configuration looks like this:

[source,xml,linenums]
----
<http:request method="GET" config-ref="HTTP_Request_configuration" path="/testpath">
			<http:headers ><![CDATA[#[[{'HeaderName1' : 'HeaderValue1'}]]]]></http:headers>
		</http:request>
----

The following example shows how to configure *Headers* at HTTP global connection level in Studio:

. Select the HTTP *Request* operation from your flow.
. In *General*, select the *Headers* tab.
. Click the plus sign (*+*) next to the *Connector configuration* field to configure a global element that can be used by all instances of HTTP *Request* in the app.
. Click *Settings*.
. Set *Default headers* to *Edit inline*.
. Click the plus sign (*+*) to add a new header.
. Set *Key* to `x-csrf-token`.
. Set *Value* to `Fetch`.
. Click *Finish*.

image::http-listener-3.png[Default headers configuration at HTTP Request global connection]

In the *Configuration XML* editor, the `default-headers` configuration looks like this:

[source,xml,linenums]
----
<http:default-headers >
    <http:default-header key="x-csrf-token" value="Fetch" />
</http:default-headers>
----

The following example shows how to configure default headers with DataWeave expressions, allowing you to use dynamic values:

. In the *Default headers* configuration window.
. For *Value*, select the *fx* button to switch to literal mode.
. Set *Value* to `#[vars.role]`.

image::http-listener-3.png[Default headers configuration at HTTP Request global connection]

In the *Configuration XML* editor, the `default-headers` configuration looks like this:

[source,xml,linenums]
----
<http:request-config name="requestConfig">
    <http:default-headers >
        <http:default-header key="custom-role" value="#[vars.role]" />
    </http:default-headers>
</http:request-config>
----

Using DataWeave expressions in a configuration element constitutes a dynamic configuration. Each time a Mule app uses an HTTP *Request* operation, all expressions in the configuration are evaluated and for each set of distinct values, a new configuration instance is created and initialized.

For HTTP Connector, use default headers with small value expressions. Otherwise, every single evaluation returns a different value and creates several instances of the HTTP client. This behavior affects performance because of the extra work that takes to initialize a client and can be resource-consuming.

In such cases, configure headers with expressions at the HTTP *Request* operation level, for example:

[source,xml,linenums]
----
<http:request config-ref="requestConfig" method="#[attributes.method]" path="#[attributes.maskedRequestPath]">
	<http:headers>#[{'custom-role':vars.role}]</http:headers>
</http:request>
----

== Configure Query Parameters

To configure *Query Parameters* for the HTTP request, follow these steps:

. In Studio, select the HTTP *Request* operation from your flow.
. In *General*, select the *Query Parameters* tab.
. Click the plus sign (*+*) to add a parameter to the request.
. In the *Name* column, change *"Key"* to `"Keyquery"`.
. In the *Value* column, change *"Value"* to `"Valuequery"`.

image::http-listener-3.png[Query parameters configuration with Key field set to Keyqueryand Value field set to Valuequery]

In the *Configuration XML* editor, the `query-params` configuration looks like this:

[source,xml,linenums]
----
<http:request method="GET" config-ref="HTTP_Request_configuration" path="/testpath">
			<http:query-params ><![CDATA[#[output application/java
---
{
	"keyquery" : "Valuequery"
}]]]></http:query-params>
		</http:request>
----

You can use DataWeave expressions to add query parameters as well, for example:

. In the HTTP *Request* operation configuration window, select the *Query Parameters* tab.
. Select the *fx* button to switch to literal mode.
. In the box, add the DataWeave expression `[{'Keyquery' : 'Valuequery'}]`.

image::http-listener-3.png[Query parameters configuration with DataWeave expression]

In the *Configuration XML* editor, the `query-params` configuration looks like this:

[source,xml,linenums]
----
<http:request method="GET" config-ref="HTTP_Request_configuration" path="/testpath">
			<http:query-params ><![CDATA[#[[{'Keyquery' : 'Valuequery'}]]]]></http:query-params>
		</http:request>
----

== Configure URI Parameters

You configure a URI parameter when you want to use a placeholder, such as `/customer/{customerId}`, in the path of your request. To configure a URI parameter, type the placeholder enclosed in curly brackets in the *Path* field. Select *URI Parameters*, click *+*, and enter a name and value.

For example, enter *customerId* and *20* as the name and value.

image::http-mule4-uriparams.png[]

Alternatively, you can use DataWeave expressions in the name and value fields.

When the application runs, it performs a GET request to `+http://www.example.com/customer/20+`.

=== Dynamic Parameters and Headers

If, at design time, you don't know how many query parameters or headers a request might need, use DataWeave and a variable map to dynamically assign parameters or headers to the request.

For example, you create a map variable named `customMap` and assign the variable a map of values using DataWeave, then use that variable to set up the headers of your request:

`#[vars.customMap ++ {'HeaderName1' : 'HeaderValue1'}]`

To set URI parameters dynamically, use a DataWeave expression that returns a map of the parameters. For example:

* Set Path to: `/test/{p1}/{p2}`
* URI Parameter names: p1 and p2
* URI Parameter value: `#[vars.customMap]`
* Before the request, assuming p1 already set: `#[vars.customMap ++ {'p2': 'customer'}]`

The connector resolves parameters for each request, and evaluates DataWeave expressions in the context of the current message, in the order specified in the request. If the same parameter is defined more than once, the latest value is used.


=== Sending Form Parameters in a POST Request

To send parameters in a POST request, In *General > Request*, select the *POST* method.
In *Body*, construct the payload of the Mule message as `application/x-www-form-urlencoded` with the names and the values of the parameters to send. For example:

`#[output application/x-www-form-urlencoded --- {'key1':'value1', 'key2':'value2'}]`

A POST request is sent to the host location you specify with `Content-Type: application/x-www-form-urlencoded`, and the body is "`key1=value1&key2=value2`".

== Map Between HTTP Responses and Mule Messages

An HTTP response is mapped to a Mule message similar to the way the HTTP request is mapped to a Mule message.

The following elements *don't* apply to HTTP responses:

* Query parameters
* URI parameters
* Inbound attributes related to the HTTP request URI

In addition, the HTTP request operation adds the following attributes to the Mule message when receiving a response:

* `attributes.statusCode`: Status code of the HTTP response
* `attributes.reasonPhrase`: Reason phrase of the HTTP response

== Round-Robin Requests

The request operation connects to configured hosts using round robin DNS. Mule runtime engine resolves all IP addresses associated to the specified host and performs load balancing by distributing the requests across all returned IPs.

When connecting to resources that require authentication, the external service needs to replicate session information between IP addresses under the host of your service. Otherwise, your requests might get rejected for being unauthorized.

When your external resource does not handle sticky sessions you need to add the service host name to the `mule.http.disableRoundRobin` system property when starting the Mule Runtime:

[source,console]
----
./mule -M-Dmule.http.disableRoundRobin=serverhostname.com
----

When configured in this way, the request does not use round robin DNS when connecting to the configured host.

== HTTP Response Validation

When the HTTP request operation receives an HTTP response, it validates the response through its status code. By default, it throws an error when the status code is higher than or equal to 400. Consequently, if the server returns a 404 (Resource Not Found) or a 500 (Internal Server Error) a failure occurs and error handling is triggered.

To get a detailed overview of an HTTP response body when an exception is thrown during an HTTP request call, review the following xref:mule-runtime::mule-error-concept.adoc#http-request-error[example] in the Mule Errors documentation.

You can change the set of valid HTTP response codes by configuring *General > Response > Response Validator*.

* None: Connector uses the default validator, which throws an error when the status code is greater than or equal to 400.
* Success Status Code Validator: All the status codes defined within this element are considered valid. The request throws an error for any other status code.
* Failure Status Code Validator: All the status codes defined within this element are considered invalid and an error is thrown. The request is considered valid with any other status code.

To set which status codes are acceptable as successful responses, in *General > Response > Response Validator*, select *Success Status Code Validator*. In *Values*, enter the list of acceptable status codes, separated by commas. For example: *200,201*. If the HTTP response has any other status value, it fails and raises an error.

A range of failure status codes is defined by two ASCII `..` full stop characters. Any value between 500 and 599 is considered a failure and raises an error. If the HTTP response has any other status value, it's considered a success.

== Configure a Target

By default, the body of a request is taken from the `#[payload]` of the incoming Mule message and the response is sent onwards as the `#[payload]` of the output Mule message. You can change this default behavior through the *General > Request > Body* and *General > Output > Target Variable* attributes. Use this attribute to specify a location other than payload for the output data, such as a variable.

== Configure Request Streaming Mode

When HTTP Connector manages request bodies, the connector considers the type of data to send. You can configure the HTTP *Request* operation to send HTTP requests in chunks. By default, if the payload type is stream, the operation uses the streaming mechanism to send HTTP requests. +

To control this behavior, configure *Request streaming mode* to any of these options:

* *ALWAYS* +
Always enable streaming regardless of the payload type.
* *AUTO* (default) +
The behavior depends on the payload type. If the payload is a stream, streaming is enabled. Otherwise, it is disabled.
* *NEVER* +
Never stream, even if the payload is a stream.

When streaming, the HTTP request does not contain the `Content-Length` header. The request contains the `Transfer-Encoding` header and sends the body in chunks until the stream is fully consumed.

The following example shows how to configure *Request streaming mode* in Studio:

. In the *Mule Palette* view, select *HTTP > Request*.
. Drag *Request* to the Studio canvas.
. Set *Path* to `/path`.
. In the HTTP *Request* operation configuration screen, click the *Request* tab.
. Set *Request streaming mode* to `ALWAYS`.

image::http-request-requeststreaming.png[HTTP Request configuration window with Response streaming mode field set to ALWAYS]

In the *Configuration XML* editor, the `requestStreamingMode` configuration looks like this:

[source,xml,linenums]
----
<flow name="httprequestFlow"  >
		<http:request method="GET" requestStreamingMode="ALWAYS" config-ref="HTTP_Request_configuration" path="/path"/>
	</flow>
----

=== Configure the Request Streaming System Property

The previous *Request streaming mode* configuration causes the Mule app to send HTTP requests in chunks, but the configuration doesn't imply that the Mule app streams the payload internally. The HTTP *Request* operation needs all the data in memory before sending HTTP requests. Therefore, if the Mule app needs to send a very large request body, the Mule app can generate a high memory consumption, and eventually cause an out-of-memory error. To prevent this issue, Mule provides the `mule.http.requestStreaming.enable` system property to enable internal request streaming.

If you configure this system property, the HTTP *Request* operation starts sending the request body before all of the data is in memory. Therefore, the Mule app won't need as much memory as it would need if you don't configure this property.

To configure this system property, set it when starting Mule by adding: +
 `-M-Dmule.http.requestStreaming.enable=true` +
 This property defaults to `false`.

You can also configure the internal buffer `mule.http.requestStreaming.bufferSize` system property for the streaming mechanism. +
To configure this property, set it when starting Mule by adding: +
 `-M-Dmule.http.requestStreaming.bufferSize=value` +
This property is measured in bytes and defaults to `8192`.

To learn how to set system properties in Anypoint Studio or for on-premises deployments, refer to the xref:mule-runtime::mule-app-properties-system.adoc[system properties] documentation.

== Configuring Response Streaming

When requesting a large payload, you can choose to stream the response by setting the `streamResponse` attributes in the HTTP request configuration.

By default, the `streamResponse` attribute is set to false. When setting this attribute to true, you enable Mule to handle the response as a stream by saving chunks to an in-memory buffer. You can configure the buffer size using the `responseBufferSize` attribute, but its default size is 10 KB.

[source,xml,linenums]
----
<http:request-config name="requestConfig">
    <http:request-connection host="localhost" port="8081" streamResponse="true" responseBufferSize="1024"/>
</http:request-config>
----

To avoid issues, it's important to consume responses when streaming.

== Retry Mechanisms

The HTTP Connector uses a retry mechanism that enables you to configure how many times it tries consuming an external HTTP service. The HTTP Connector uses this mechanism to reconnect an HTTP client with an HTTP service. The HTTP Connector does not manage TCP connections, so this mechanism does not reconnect sockets.

[WARNING]
The *HTTP Request* operation does not use the reconnection strategy for retries. The reconnection strategy is a mechanism the Mule SDK uses to re-establish _Connections_ when a `ConnectionException` is caught. It does not affect connections to an HTTP service created by the HTTP Requester.
To learn more about _Connections_, see xref:mule-sdk::connections.adoc[Connections documentation]

To configure how many times the HTTP Requester can try consuming an external HTTP service (_retries_), you can either use the Until Successful scope, or the built-in retry mechanism in the requester:

* Until Successful scope +
The Until Successful scope processes the components within it, in order, until they succeed or exhaust the maximum number of retries. Enclosing the HTTP Requester in this scope, enables you to configure the maximum number of retries `maxRetries`, and the time `millisBetweenRetries` between them, for example:

[source,xml,linenums]
----
<until-successful maxRetries="5" millisBetweenRetries="10000">
    <http:request method="GET" config-ref="requestConfig" />
</until-successful>
----

For additional information on the scope, see xref:mule-runtime::until-successful-scope.adoc[Until Successful Scope].

* Built-in mechanism +
When the HTTP Requester receives an error of type `Remotely Closed`, the requester automatically retries by default the idempotent methods `PUT`, `DELETE`, `GET`, `HEAD`, `OPTIONS`, and `TRACE`, three times before it fails. +
Thereby, you can configure two system properties for this mechanism:

** `-M-Dmule.http.client.maxRetries=5` +
This system property enables to configure the number of retries before the HTTP Requester fails, additionally, you can also set its value to zero to avoid using the built-in mechanism.

** `-M-Dmule.http.client.retryOnAllMethods=true` +
This system property extends the built-in mechanism to all the methods, and not only the idempotent ones.

For additional information on these properties, see xref:mule-runtime::mule-app-properties-system.adoc[System Properties], and to understand why nonidempotent methods, such as `POST`, aren't retried by default, refer to https://tools.ietf.org/html/rfc7230#section-6.3.1[RFC 7230].

== See Also

* xref:mule-runtime::intro-engine.adoc#thread-pools-and-tuning-apps[Mule 4 Thread Pools and Tuning apps]
* xref:mule-runtime::until-successful-scope.adoc[Until Successful Scope]
* xref:http-documentation#HttpRequestAttributes[HTTP Request Attributes Reference]
* xref:http-documentation#HttpResponseAttributes[HTTP Response Attributes Reference]
