= Configure an HTTP Listener Source - Mule 4
:page-aliases: connectors::http/http-listener-ref.adoc

The Anypoint Connector for HTTP (HTTP Connector) *Listener* source enables you to set up an HTTP server and trigger flows when receiving HTTP requests.

You can choose what methods the source accepts, such as `GET`and `POST` or a list of methods, and in which *Path* to receive HTTP requests, thereby allowing the routing of requests through different flows.

When the HTTP *Listener* source receives an HTTP request, the source triggers the flow with the request data. The HTTP body is set as the payload, and the remaining HTTP data as attributes, such as headers and query parameters.

When the flow finishes its execution, the HTTP *Listener* source sends an HTTP response based on whether the flow execution was successful or not, which returns different status codes. You can also customize how the source generates HTTP responses in the connector source configuration.

== Configure HTTP Listener Connection

To use an HTTP *Listener* source, you must configure a connection to the HTTP server that listens to the following settings:

* *Host* +
Indicates where the requests are sent.
* *Port* +
Indicates where the requests are received.
* *Protocol* +
Indicates the protocol for communication, it can be HTTP for plain connections or HTTPS for TLS secure connections.

To enable secure connections through HTTPS, you must define a TLS context in the connection and provide:

* A keystore for the server
* A truststore if you need two-way authentication

Refer to the xref:mule-runtime::tls-configuration.adoc[TLS Configuration] documentation for details.

Additionally, you can configure a *Base path* that applies to all sources using the configuration.

The following example shows how to configure the HTTP *Listener* connection in Studio:

. In the *Mule Palette* view, select *HTTP>Listener*.
. Drag *Listener* to the Studio canvas.
. Set *Path* to `/test`.

image::http-listener-1.png[HTTP Listener configuration window and Path field set to /test]

[start=4]
. Click the plus sign (*+*) next to the *Connector configuration* field to configure a global element that can be used by all instances of HTTP *Listener* in the app.
. Set *Host* to `0.0.0.0` and *Port* to `8081`.

image::http-listener-2.png[HTTP Listener global configuration window with Host field set to 0.0.0.0 and Port field to 8081]

[start=6]
. Click the *TLS* tab.
. Set *TLS configuration* to *Edit inline*.
. Set *Path* to `keystore.jks` and *Password* to `MyP455W0rD`.
. Click *OK*.

image::http-listener-3.png[HTTP Listener TLS configuration window with Path field set to keystore.jks and Passwordd field to MyP455W0rD]

In the Configuration XML editor, the `host`, `port`, `path` and `trust-store` configurations look like these:

[source,xml,linenums]
----
<http:listener-config name="HTTP_Listener_config" d >
		<http:listener-connection host="0.0.0.0" port="8081" >
			<tls:context >
				<tls:trust-store path="keystore.jks" password="MyP455W0rD" />
			</tls:context>
		</http:listener-connection>
	</http:listener-config>
  <flow name="test" >
		<http:listenerconfig-ref="HTTP_Listener_config" path="/path"/>
	</flow>
----

To configure the *Base path* for the source:

. In the HTTP *Listener* configuration screen, click the plus sign (*+*) next to the *Connector configuration* field to configure a global element.
. In *HTTP Listener config*, set *Base path* to `api/v1`.
. Click *OK*.

image::http-listener-4.png[HTTP Listener global configuration window with Base path field set to api/v1]

In the Configuration XML editor, the `basePath` configuration looks like this:

[source,xml,linenums]
----
<http:listener-config name="HTTP_Listener_config" basePath="api/v1">
  <http:listener-connection host="0.0.0.0" port="8081" />
</http:listener-config>
----

[NOTE]
If you deploy a project to CloudHub, set *Host* to *0.0.0.0* so the connection listens to all the interfaces of the machine. +
If you deploy locally for testing purposes, set *Host* to *localhost* to receive only requests that are generated locally. The app is not vulnerable to external threats.

You can also configure advanced settings that can define whether the connections are persistent and if they are not, the timeout the connections will have.


== Configure Paths

Because an HTTP *Listener* source acts as an event trigger within flows, it  must reference the configuration to use and the *Path* where the source listens for HTTP requests.

Paths can be static, which requires exact matches, or feature placeholders. Placeholders can be:

* Wildcards (`*`) +
Match against anything they are compared to.
* Parameters (`{param}`) +
Match not only against anything but also capture those values on a URI parameters map.

[NOTE]
Wildcards at the end of a path can help provide better error messages by capturing requests to unmanaged resources.

The following examples show different *Path* configurations for three HTTP *Listener* sources that have a *Base path* set to `api/v1`:

* `account/mulesoft/main-contact` +
Matches only the exact path request `+http://awesome-company.com/api/v1/account/mulesoft/main-contact+`.
* `account/{accountId}/main-contact` +
Matches all path requests structured similarly, such as `+http://awesome-company.com/api/v1/account/salesforce/main-contact+`, and save `salesforce` as the value of `accountId`.
* `account/{accountId}/*` +
Matches all path requests different from `main-contact`, such as `+http://awesome-company.com/api/v1/account/mulesoft/users+`, and save `mulesoft` as the value of `accountId`.

When the Mule app has multiple HTTP *Listener* sources, HTTP requests are always routed to the most specific source. In the previous examples, the first HTTP *Listener* source receives a request with `accountId: mulesoft` and suffix `main-contact`, and the second source receives any different `accountId` value.


== Configure Allowed Methods

HTTP requests are routed based on the HTTP method received. By default, an HTTP *Listener* source supports all methods. You can also restrict the methods of your choice, even configure custom ones.

The following example shows how to configure *Allowed methods* in Studio:

. In the *Mule Palette* view, select *HTTP>Listener*.
. Drag *Listener* to the Studio canvas.
. In the HTTP *Listener* source configuration screen, click the *Advanced* tab.
. Set *Allowed methods* to `GET`.

image::http-listener-5.png[HTTP Listener configuration window and Allowed methods field set to GET]

In the Configuration XML editor, the `allowedMethods` configuration looks like this:
[source,xml,linenums]
----
<http:listener path="/test" allowedMethods="GET" config-ref="HTTP_Listener_config"/>
----

When a Mule app has multiple HTTP *Listener* sources defined, requests are routed to the first source matching the method, so default sources should always be defined last.

The following example shows different HTTP *Listener* sources configuration where the *Allowed method* is set to `GET`, `POST` and `PUT`. Therefore, HTTP requests are routed to different flows based on the restriction of data visibility. You might allow certain users to see your data but only a few users to modify it:

[source,xml,linenums]
----
<flow name="main-contact-write">
  <http:listener path="account/{accountId}/main-contact" allowedMethods="POST, PUT" config-ref="HTTP_Listener_config"/>
  <!-- validate user permissions -->
  <!-- store or update main contact for accountId -->
</flow>

<flow name="main-contact-read">
  <http:listener path="account/{accountId}/main-contact" allowedMethods="GET" config-ref="HTTP_Listener_config"/>
  <!-- fetch main contact for accountId -->
</flow>

<flow name="main-contact-general">
  <http:listener path="account/{accountId}/main-contact" config-ref="HTTP_Listener_config"/>
  <set-payload value="#['The main contact resource does not support ' ++ attributes.method ++ ' requests.']"
</flow>
----

== Configure Response Streaming Mode

When HTTP Connector manages response bodies, the connector considers the type of data to send and uses _chunked_ encoding when the body size is not clear. This behavior is also known as streams with no size information.

To change this behavior configure the *Response streaming mode* to any of these options:

* *AUTO (default)* +
Uses `Content-Length` encoding if a size is defined for the body, otherwise uses `Transfer-Encoding: chunked`.
* *ALWAYS* +
Uses `Transfer-Encoding: chunked` regardless of any size data present.
* *NEVER* +
Uses `Content-Length` encoding, consuming streams if necessary to determine the data size.

The following example shows how to configure  *Response streaming mode* in Studio. In the example, the main contact data for an account always returns `Content-Length` encoding:

. In the *Mule Palette* view, select *HTTP>Listener*.
. Drag *Listener* to the Studio canvas.
. Set *Path* to `account/{accountId}/main-contact`.
. In the HTTP *Listener* source configuration screen, click the *Advanced* tab.
. Set *Allowed methods* to `GET`.
. Set *Response streaming mode* to `NEVER`.

image::http-listener-6.png[HTTP Listener configuration window with Allowed methods field set to GET and Response streaming mode field set to NEVER]

In the Configuration XML editor, the `allowedMethods` and `responseStreamingMode` configurations look like these:

[source,xml,linenums]
----
<flow name="main-contact-read">
  <http:listener path="account/{accountId}/main-contact" allowedMethods="GET" responseStreamingMode="NEVER" config-ref="HTTP_Listener_config"/>
  <!-- fetch main contact for accountId -->
</flow>
----

== Configure Read Timeout

To configure the read timeout for the source, in the HTTP *Listener* configuration window, set the *Read timeout* field to the desired value:

image::http-listener-7.png[HTTP Listener configuration window with Read timeout field set to 30000]

In the Configuration XML editor, the `readTimeout` configuration looks like these:

[source,xml,linenums]
----
<http:listener-config >
		<http:listener-connection host="0.0.0.0" port="8081" readTimeout="3000" />
	</http:listener-config>
----

== Configure Reject Invalid Transfer Encoding

To reject requests with invalid Transfer-Encoding headers, in the HTTP *Listener* configuration window, select the *Reject invalid transfer encoding* field:

image::http-listener-8.png[HTTP Listener configuration window with Reject invalid transfer encoding field selected]

In the Configuration XML editor, the `rejectInvalidTransferEncoding` configuration looks like these:

[source,xml,linenums]
----
<http:listener-config rejectInvalidTransferEncoding="true">
		<http:listener-connection host="0.0.0.0" port="8081" readTimeout="3000" />
</http:listener-config>
----


== Listening to HTTP Requests

When an HTTP *Listener* source receives an HTTP request, the data from the HTTP request line includes the method, request path, query, URI parameters, and headers as attributes. The body sets the payload, and the `Content-Type` header sets the  MIME type, which enables other components to inspect the payload MIME type. For example, DataWeave works with an HTTP payload without requiring any input information. Additionally, if an HTTP request contains an `X-Correlation-ID` or `MULE_CORRELATION_ID` (for interoperability with Mule 3) header, it sets the message's correlation ID for traceability.

=== HTTP Request Example

The following example shows an HTTP request:

[source,JSON,linenums]
----
POST api/v1/account/salesforce/main-contact?overwrite=true&notify=jane.doe&notify=admin HTTP/1.1
Host: localhost:8081
Content-Type: application/json
Content-Length: 166
X-Correlation-ID: 9cf32672-4f0b-4e8b-b988-40c13aae85b4

{
  "name": "John",
  "surname": "Doe",
  "role": "Senior Vice President",
  "organization": "Marketing",
  "phone": 701222369,
  "email": "john.doe@salesforce.com"
}
----

The message's correlation ID is `9cf32672-4f0b-4e8b-b988-40c13aae85b4`.

The payload is in JSON format:

[source,JSON,linenums]
----
{
  "name": "John",
  "surname": "Doe",
  "role": "Senior Vice President",
  "organization": "Marketing",
  "phone": 701222369,
  "email": "john.doe@salesforce.com"
}
----

The attributes include:

* method: `POST`
* listenerPath: `api/v1/account/{accountId}/main-contact`
* requestPath: `api/v1/account/salesforce/main-contact`
* relativePath: `account/salesforce/main-contact`
* queryParams: a multi-map with entries `overwrite=true`, `notify=jane.doe` and `notify=admin`
* uriParams: a map with entry `accountId => salesforce`
* headers: a multi-map with entries `Host=localhost:8081`, `Content-Type=application/json`, `Content-Length=166` and `X-Correlation-ID=9cf32672-4f0b-4e8b-b988-40c13aae85b4`

A DataWeave expression such as `#[payload.name ++ ' ' ++ payload.surname]` returns `John Doe` because DataWeave correctly interprets the JSON data.

A DataWeave expression such as `#['Received a ' ++ attributes.method ++ ' request for account ' ++ attributes.uriParams.accountId ++ '. The following users are notified: ' ++ (attributes.queryParams.*notify joinBy ', ')]` returns `Received a POST request for account salesforce. The following users are notified: admin, jane.doe`.

[NOTE]
Multi-maps are similar to maps except they allow several values for a given key. Multi-maps return the first value when using a single-value selector (`.`), but they allow to retrieve all values when using the multiple-value selector (`.*`).

=== HTTP Request Multipart Form-Data Example

The following example shows an HTTP request of an HTML form received by an HTTP *Listener* source. Additionally, the example shows how to use DataWeave expressions to read `multipart/form-data` content.

Based on the following HTML form:

[source,xml,linenums]
----
<form action="http://server.com/cgi/handle"
        enctype="multipart/form-data"
        method="post">

    How would you like to identify the logo? <INPUT type="text" name="name"><BR>
    Which is the logo file? <INPUT type="file" name="logo"><BR>
    What is the main color in the logo? <INPUT type="text" name="color"><BR>
    <INPUT type="submit" value="Send"> <INPUT type="reset">

</form>
----

The HTTP *Listener* source receives the following `multipart/form-data` HTTP request:

[source,text,linenums]
----
POST /api/v1/account/mulesoft/logo HTTP/1.1
Content-Type: multipart/form-data; boundary=489691234097965980223899
Host: localhost:8081
content-length: 34332

--489691234097965980223899
Content-Disposition: form-data; name="name"

Corporate Logo
--489691234097965980223899
Content-Disposition: form-data; name="logo"; filename="MuleSoft_logo.png"
Content-Type: image/png

.PNG
.
...
IHDR.......L......~.....	pHYs...#...#.x.?v.. .IDATx....q.W.6.....~".N....t....t..#.....LD0T.CF0b..:.3......Q..@...q]U*y\c....
....`%.$....V"H....`%.$....V"H....`%.$....V"H....`%.$....V"H....`%.$....V"H....`%.$....V"H....`%.$....V"H....`%.$....V"H....`%
.$....V"H....`%.$....V"H....`%.$....V"H....`%.$....V"H....`%.$....V"H....`%.$....^6.......|..P.....IEND.B`.
--489691234097965980223899
Content-Disposition: form-data; name="color"

blue
--489691234097965980223899--
----

You can use DataWeave expressions to access and read each HTTP request parameter data through the `parts` object, either by name or item number. For example, to access the second part of the HTTP request that contains the `Corporate Logo` parameters data, you can use `payload.parts.logo` or `payload.parts[1]`. The latter is useful when a name is not provided.

Within each part, you can access its content and headers. For example, `payload.parts.color.content` returns `blue`, while `payload.parts.logo.headers.'Content-Type'` returns `application/png`.

You can also access the filename of a part. For example, the `Content-Disposition` header is parsed to allow an expression like `payload.parts.logo.headers.'Content-Disposition'.filename`, which in this case returns `MuleSoft_logo.png`.

Refer to the xref:dataweave::dataweave-formats.adoc[Formats Supported by DataWeave] documentation to learn about reading and writing multipart content.

== Sending HTTP Responses

After the triggered flow finishes its execution, the HTTP *Listener* source sends an HTTP response with the result. If the flow executes successfully, the source sends an HTTP regular response. Otherwise, the source sends an HTTP error response.
By default, an HTTP regular response returns a 200 status code and the message payload as the body, while an HTTP error response returns a 500 status code with the flow error's description as the body.

In the HTTP *Listener* source configuration, you can customize HTTP responses by providing the following parameters. Note that you can use DataWeave to generate content for each parameter, and variables to propagate data from the flow:

* *Body*
* *Headers*
* *Status code*
* *Reason phrase*

=== Create Sending HTTP Responses Mule App Example

The following example shows how to configure HTTP responses for the HTTP *Listener* source in Studio. The example is a Mule app flow where an endpoint stores logos for an account:

* When the storage is successful, an HTTP regular response returns with status code `201`, reason phrase `Created`, and body as `Corporate Logo has been stored as a MuleSoft logo`.
* When the storage fails, an HTTP error response returns where the status code is defined through the `errorCode` variable (if available) or a `500` code by default.
** The custom header returns `X-Time`.
** The body returns `Corporate Logo could not be stored`.
** If there is a `CONNECTIVITY` error storing the logo, the returned status code is `504`, while any other errors result in a `500` status code.

While a reason phrase is not defined for error responses, HTTP Connector attempts to define a reason phrase based on the status code. Thereby, a `Gateway Timeout` or `Internal Server Error` error can return for the previous explained HTTP responses scenarios.

To create the Mule app in Studio, follow these steps:

. In the *Mule Palette* view, select *HTTP>Listener*.
. Drag *Listener* to the Studio canvas.
. Set *Path* to `/account/{accountId}/logo`.
. Click the plus sign (*+*) next to the *Connector configuration* field to configure a global element that can be used by all instances of HTTP *Listener* in the app.
. Set *Host* to `0.0.0.0` and *Port* to `8081`.
. Click *OK*.
. In the HTTP *Listener* configuration screen, click the *Responses* tab.
. In the *Response* section, set these values:
+
* *Body* : `output text/plain --- vars.logoName ++ ' has been stored as a ' ++ vars.accountId ++ ' logo.'`
* *Status code* : `201`
* *Reason phrase* : `Created`

[start=9]
. In the *Error Response* section, set these values:
+
* *Body* : `vars.logoName ++ ' could not be stored.'`
* *Headers* :
+
[source,DataWeave,linenums]
----
output application/java
        ---
        {
          "X-Time" : "50s" // 4
        }
----
* *Status code* : `vars.errorCode default 500`.

image::http-listener-9.png[HTTP Listener Responses configuration window with Body, Header, Status Code and Reason phrase fields]

[start=10]
. Drag a *Set Variable* component to the right of HTTP *Listener*.
. Set *Name* to `logoName`.
. Set *Value* to `payload.parts.name.content`.
. Drag another *Set Variable* component to the right of first *Set Variable* component.
. Set *Name* to `accountId`.
. Set *Value* to `attributes.uriParams.accountId`.
. Drag an *Insert*  operation to the right of  the second *Set Variable* component.
. Click the plus sign (*+*) next to the *Connector configuration* field to configure the database connection.
. In the *Insert* operation configuration screen, set *SQL Query Text* to `INSERT INTO logo (accountId,logoName)`.
. Drag an *On Error Propagate* component in the *Error handling* section of the flow.
. Set *Type* to `DB:CONNECTIVITY`.
. Drag a *Set Variable* component into the *On Error Propagate* component.
. Set *Name* to `errorCode`.
. Set *Value* to `504`.

=== XML for Sending HTTP Responses Example

Paste this code into your Studio XML editor to quickly load the flow for this example into your Mule app:

[source,xml,linenums]
----
<?xml version="1.0" encoding="UTF-8"?>

<mule xmlns:db="http://www.mulesoft.org/schema/mule/db" xmlns:os="http://www.mulesoft.org/schema/mule/os"
	xmlns:http="http://www.mulesoft.org/schema/mule/http"
	xmlns="http://www.mulesoft.org/schema/mule/core" xmlns:doc="http://www.mulesoft.org/schema/mule/documentation" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.mulesoft.org/schema/mule/core http://www.mulesoft.org/schema/mule/core/current/mule.xsd
http://www.mulesoft.org/schema/mule/http http://www.mulesoft.org/schema/mule/http/current/mule-http.xsd
http://www.mulesoft.org/schema/mule/os http://www.mulesoft.org/schema/mule/os/current/mule-os.xsd
http://www.mulesoft.org/schema/mule/db http://www.mulesoft.org/schema/mule/db/current/mule-db.xsd">
	<http:listener-config name="HTTP_Listener_config" >
		<http:listener-connection host="0.0.0.0" port="8081" />
	</http:listener-config>
	<db:config name="Database_Config" >
		<db:derby-connection />
	</db:config>
	<flow name="httplistenerresponseFlow"  >
		<http:listener config-ref="HTTP_Listener_config" path="/account/{accountId}/logo">
			<http:response statusCode="201" reasonPhrase="Created">
				<http:body ><![CDATA[output text/plain --- vars.logoName ++ ' has been stored as a ' ++ vars.accountId ++ ' logo.']]></http:body>
			</http:response>
			<http:error-response statusCode="#[vars.errorCode default 500]" >
				<http:body ><![CDATA[vars.logoName ++ ' could not be stored.']]></http:body>
				<http:headers ><![CDATA[#[output application/java
        ---
        {
          "X-Time" : "50s" // 4
        }]]]></http:headers>
			</http:error-response>
		</http:listener>
		<set-variable value="payload.parts.name.content" variableName="logoName"/>
		<set-variable value="attributes.uriParams.accountId"  variableName="accountId"/>
		<db:insert doc:name="Insert" config-ref="Database_Config">
			<db:sql ><![CDATA[INSERT INTO logo (accountId,logoName)]]></db:sql>
		</db:insert>
		<error-handler >
			<on-error-propagate enableNotifications="true" logException="true" doc:name="On Error Propagate"  type="DB:CONNECTIVITY">
				<set-variable value="504" variableName="errorCode"/>
			</on-error-propagate>
		</error-handler>
	</flow>
</mule>
----

== See Also

* xref:http-documentation.adoc[HTTP Connector Reference]
* xref:http-troubleshooting.adoc[HTTP Connector Troubleshooting Guide]
* xref:dataweave::dataweave-formats.adoc[DataWeave Formats]
* xref:mule-runtime::tls-configuration.adoc[TLS Configuration]
* xref:http-documentation#HttpRequestAttributes[HTTP Request Attributes Reference]
* xref:http-documentation#HttpResponseAttributes[HTTP Response Attributes Reference]
