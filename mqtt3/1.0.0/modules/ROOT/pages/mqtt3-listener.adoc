= Listen for New Messages
:page-aliases: connectors::mqtt3/mqtt3-listener.adoc

The MQTT3 Connector allows you to listen for new incoming messages for one or more topic filters and with a specific quality of service for each one.

The listener could subscribe to multiple individual topics:

[source,xml,linenums]
----
    <flow name="listenerAuthorQuotes">
        <mqtt3:listener config-ref="MQTT_Config">
            <mqtt3:topics>
                <mqtt3:topic topicFilter="quotes/terryPratchett" qos="EXACTLY_ONCE"/>
                <mqtt3:topic topicFilter="quotes/neilGaiman" qos="AT_LEAST_ONCE" />
                <mqtt3:topic topicFilter="quotes/ianMcEwan" qos="AT_MOST_ONCE" />
            </mqtt3:topics>
        </mqtt3:listener>
    </flow>
----

== Single-Level WildCards

You can use single-level wildcards to listen to multiple topics:

[source,xml,linenums]
----
    <flow name="listenerArgentinaTemperature">
        <mqtt3:listener config-ref="${config}">
            <mqtt3:topics>
                <mqtt3:topic topicFilter="quotes/+/authors"/>
            </mqtt3:topics>
        </mqtt3:listener>

        <logger level="DEBUG" message="A quote has been published to #[attributes.topic]: #[payload]"/>
    </flow>
----

This will enable the subscriber to receive messages published to all topics matching the structure 'quotes/+/authors'.

So, messages published to the following topics would reach trigger our message listener:

* quotes/british/authors
* quotes/american/authors

However, messages published to the following topics would NOT trigger our message listener:

* names/british/authors
* quotes/american/writers

== Multi-Level WildCards

Or multi-level wildcards:

[source,xml,linenums]
----
    <flow name="listenerArgentinaTemperature">
        <mqtt3:listener config-ref="${config}">
            <mqtt3:topics>
                <mqtt3:topic topicFilter="quotes/england/#"/>
            </mqtt3:topics>
        </mqtt3:listener>

        <logger level="DEBUG" message="A quote has been published to #[attributes.topic]: #[payload]"/>
    </flow>
----

Multi-level wildcards allow the listener to subscribe to all topics that share same root (everything that comes before '#').

So, messages published to the following topics would reach trigger our message listener:

* quotes/england/authors/terryPratchett
* quotes/england/authors/neilGaiman
* quotes/england/actors

However, messages published to the following topics would NOT trigger our message listener:

* quotes/american/actors
* phrases/england/authors/neilGaiman

== Sharing Configuration

Listeners that share a configuration element will also share a connection and client id. This is important to keep in mind
especially in the cases where one of the listeners is stopped but the other isn't.

Suppose we have the following configuration element and listeners in our application:

[source,xml,linenums]
----
<mqtt3:config name="MQTT_Config">
    <mqtt3:connection clientId="smart-bentley-123" url="tcp://127.0.0.1:1883" />
</mqtt3:config>

<flow name="listenerReaderA">
   <mqtt3:listener config-ref="MQTT_Config">
            <mqtt3:topics>
                <mqtt3:topic topicFilter="shakespeare"/>
                <mqtt3:topic topicFilter="terryPratchett"/>
            </mqtt3:topics>
   </mqtt3:listener>

   <logger level="INFO"  message="Received message '#[payload]' with at topic #[attributes.topic] with qos #[attributes.qos]">
</flow>

<flow name="listenerReaderB">
    <mqtt3:listener config-ref="MQTT_Config">
            <mqtt3:topics>
                <mqtt3:topic topicFilter="neilGaiman"/>
                <mqtt3:topic topicFilter="terryPratchett"/>
            </mqtt3:topics>
   </mqtt3:listener>

   <logger level="INFO"  message="Received message '#[payload]' with at topic #[attributes.topic] with qos #[attributes.qos]">
</flow>
----

As you can see, the listeners share the configuration, therefore they also share a connection and a client id, and will be indistinguishable from one another
from the broker's perspective. You will also notice, that the listeners share a subscription to the topic 'terryPratchett'. The first thing to note, is that
in this case, whichever listener subscribes first will be the one to set the subscription quality of service. Only one subscription with one quality of service
level will exist for that topic. The second observation is that, if we were to stop the 'listenerReaderB' flow, the 'listenerReaderA' flow will still
receive and process the messages for the 'terryPratchett' topic, and so, even if the configuration element has specified a cleanSession=false, the
messages that were processed while 'listenerReaderB' was offline, will not be resent to this listener.
